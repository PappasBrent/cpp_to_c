grammar: |-
  CHARACTER   := "a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"i"|"j"|"k"|"l"|"m"|"n"|"o"|"p"|"q"|"r"|"s"|"t"|"u"|"v"|"w"|"x"|"y"|"z"|"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"|"I"|"J"|"K"|"L"|"M"|"N"|"O"|"P"|"Q"|"R"|"S"|"T"|"U"|"V"|"W"|"X"|"Y"|"Z" ;
  CHAR_PREFIX :=  "L" | "u" | "U" ;
  CHAR        := [CHAR_PREFIX], "'", CHARACTER, "'" ;

triads:
  - un-preprocessed: |-
      #define A L'a'

      int main(void) {
        char a = A;
        return 0;
      }
    preprocessed: |-
      int main(void) {
        char a = L'a';
        return 0;
      }
    converted: |-
      const char A = L'a';

      int main(void) {
        char a = A;
        return 0;
      }

  - un-preprocessed: |-
      #define A u'a'

      int main(void) {
        int a = A;
        return 0;
      }
    preprocessed: |-
      int main(void) {
        int a = u'a';
        return 0;
      }
    converted: |-
      // Even though A is only used as an int in the AST,
      // it should still be converted to a u char variable since that
      // is the type its body parses to
      const char A = u'a';

      int main(void) {
        int a = A;
        return 0;
      }

  - un-preprocessed: |-
      #define A U'a'

      int main(void) {
        int a = A;
        return 0;
      }
    preprocessed: |-
      int main(void) {
        int a = U'a';
        return 0;
      }
    converted: |-
      const char A = U'a';

      int main(void) {
        int a = ;
        return 0;
      }
