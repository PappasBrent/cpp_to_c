grammar: |-
  IDENT_CHAR  :=  ? lowercase and upper case letters, and the underscore ? ;
  DEC_DIGIT   :=  "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9" ;

  IDENTIFIER  :=  IDENT_CHAR, {IDENT_CHAR | DEC_DIGIT} ;

triads:
  - un-preprocessed: |-
      #define X x

      int main(void) {
        int x = 0;
        int y = X;
        return 0;
      }
    preprocessed: |-
      int main(void) {
        int x = 0;
        int y = x;
        return 0;
      }
    converted: |-
      // Macros that use dynamic scoping are converted to functions.
      // The return type of such function is inferred from the macro's
      // expansions in the AST.

      int X(int x) { return x; }

      // More complex logic is required for macros that modify
      // their bodies; but the grammar for these triads does not
      // support such macros

      int main(void) {
        int x;
        // Their invocations are replaced with function calls,
        // and variables that were free variables in the original macro
        // are passed as arguments instead.
        int y = X(x);
        return 0;
      }

  - un-preprocessed: |-
      #define X 5
      #define Y X

      int main(void) {
        int z = Y;
        return 0;
      }
    preprocessed: |-
      int main(void) {
        int z = 5;
        return 0;
      }
    converted: |-
      const int X = 5;
      // Nested macros are treated like any other identifier.
      // If a nested macro can be converted, then it's conversion
      // will be used to determine how to convert the macro in which
      // it is nested.
      cont int Y = X;

      int main(void) {
        int z = Y;
        return 0;
      }

  - un-preprocessed: |-
      // Notice in this example that Y is defined before X, but refers
      // X in its definition
      #define Y X
      #define X 5

      int main(void) {
        int z = Y;
        return 0;
      }
    preprocessed: |-
      int main(void) {
        int z = 5;
        return 0;
      }
    converted: |-
      const int X = 5;
      // If a macro's body contains another macro who is not defined
      // at the time the parent macro is defined, the converted parent
      // macro's definition is moved right after the nested macro's
      // definition.
      cont int Y = X;

      int main(void) {
        int z = Y;
        return 0;
      }

      int main(void) {
        int z = Y;
        return 0;
      }
