# TODO: Add non-nullary functions and array indexing once expression
#       grammars are complete.

grammar: |-
  IDENT_CHAR          :=  ? lowercase and upper case letters, and the underscore ? ;
  DEC_DIGIT           :=  "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9" ;

  IDENTIFIER          :=  IDENT_CHAR, {IDENT_CHAR | DEC_DIGIT} ;

  POSTFIX_EXPRESSION  :=  POSTFIX_EXPRESSION, "(", ")"
                      |   POSTFIX_EXPRESSION, ".", IDENTIFIER
                      |   POSTFIX_EXPRESSION, "->", IDENTIFIER
                      |   POSTFIX_EXPRESSION, "++", IDENTIFIER
                      |   POSTFIX_EXPRESSION, "--", IDENTIFIER ;

triads:
  - un-preprocessed: |-
      #include <stdio.h>
      #define INC_X x++
      #define DEC_X x--

      int main(void) {
        int x = 10;
        INC_X;
        printf("%d\n", x);
        DEC_X;
        printf("%d\n", x);
        return 0;
      }
    preprocessed: |-
      int main(void) {
        int x = 10;
        x++;
        printf("%d\n", x);
        x--;
        printf("%d\n", x);
        return 0;
      }
    converted: |-
      #include <stdio.h>

      // Macros whose bodies include free variables are converted to functions,
      // and free variables that suffer from side effects are converted to
      // pass-by-reference parameters.
      // Dereferences are enclosed in parentheses.
      // The macros are converted to return int values because their
      // bodies parse to int values.
      int INC_X(int *x) { return (*x)++; }
      int DEC_X(int *x) { return (*x)--; }

      int main(void) {
        int x = 10;
        // Macro invocations are converted to function calls, and any
        // variables who suffer from side-effects will have references to them
        // passed to the function instead
        INC_X(&x);
        printf("%d\n", x);
        DEC_X(&x);
        printf("%d\n", x);
        return 0;
      }

  - un-preprocessed: |-
      #include <stdlib.h>
      #include <stdio.h>
      #include <string.h>

      #define CONNECTION_STATE conn->state

      struct Connection
      {
          char *state;
      };

      int main(void)
      {
          struct Connection *conn = (struct Connection *)malloc(sizeof(struct Connection));
          conn->state = calloc(strlen("CLOSED") + 1, sizeof(char));
          strcpy(conn->state, "CLOSED");
          printf("%s\n", CONNECTION_STATE);
          free(conn->state);
          free(conn);
          return 0;
      }
    preprocessed: |-
      int main(void)
      {
          struct Connection *conn = (struct Connection *)malloc(sizeof(struct Connection));
          conn->state = calloc(strlen("CLOSED") + 1, sizeof(char));
          strcpy(conn->state, "CLOSED");
          printf("%s\n", conn->state);
          free(conn->state);
          free(conn);
          return 0;
      }
    converted: |-
      #include <stdlib.h>
      #include <stdio.h>
      #include <string.h>

      struct Connection
      {
          char *state;
      };

      // The macro is converted to a function.
      // The free variable "conn" is not converted to a pass-by-reference
      // argument because it does not suffer from side-effects.
      // Its definition is moved after the definition of the Connection struct
      // because the converted function depends on the Connection struct being
      // defined before it is defined.
      char *CONNECTION_STATE(struct Connection *conn) { return conn->state; }

      int main(void)
      {
          struct Connection *conn = (struct Connection *)malloc(sizeof(struct Connection));
          conn->state = calloc(strlen("CLOSED") + 1, sizeof(char));
          strcpy(conn->state, "CLOSED");
          printf("%s\n", CONNECTION_STATE(conn));
          free(conn->state);
          free(conn);
          return 0;
      }

  - un-preprocessed: |-
      #include <stdio.h>

      struct Counter
      {
          int count;
      };

      #define INC_COUNT my_counter.count++

      int main(void)
      {
          struct Counter my_counter;
          my_counter.count = 0;
          INC_COUNT;
          printf("%d\n", my_counter.count);
          return 0;
      }

    preprocessed: |-
      int main(void)
      {
          struct Counter my_counter;
          my_counter.count = 0;
          my_counter.count++;
          printf("%d\n", my_counter.count);
          return 0;
      }
    converted: |-
      #include <stdio.h>

      struct Counter
      {
          int count;
      };

      // The macro is converted to a function, and its free variable
      // is converted to a pass-by-reference parameter because it suffers
      // from side-effects.
      // Dereferences of the parameter are enclosed in parentheses.
      int INC_COUNT(struct Counter *my_counter) { return (*my_counter).count++; }

      int main(void)
      {
          struct Counter my_counter;
          my_counter.count = 0;
          INC_COUNT(&my_counter);
          printf("%d\n", my_counter.count);
          return 0;
      }

  - un-preprocessed: |-
      #define CALL_F f()

      int f() { return 1; }

      int main(int argc, char const *argv[])
      {
          int x = CALL_F;
          return 0;
      }
    preprocessed: |-
      int main(int argc, char const *argv[])
      {
          int x = f();
          return 0;
      }
    converted: |-
      int f() { return 1; }

      // The macro is replaced with a function definition which calls
      // the nullary function that was present in the original macro
      // body.
      // The return value is inferred from the return value of the
      // nullary function.
      // The converted macro's function definition is moved after the
      // definition of the nullary function that was present in the macro
      // body since the converted function will need it.
      int CALL_F() { return f(); }

      int main(int argc, char const *argv[])
      {
          // Invocations to the macro are replaced with function calls.
          int x = CALL_F();
          return 0;
      }
